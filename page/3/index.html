<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>飞雪无情的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="飞雪无情的博客">
<meta property="og:url" content="http://www.flysnow.org/page/3/index.html">
<meta property="og:site_name" content="飞雪无情的博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="飞雪无情的博客">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="飞雪无情的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44570956-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">飞雪无情的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">专注于Android、Java、移动互联网、项目管理、软件架构</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://www.flysnow.org"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-android-float-widget" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2011/12/10/android-float-widget.html" class="article-date">
  <time datetime="2011-12-10T01:12:00.000Z" itemprop="datePublished">2011-12-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/12/10/android-float-widget.html">基于Android的浮动组件，可以用于应用中的新功能展示等等。</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言">前言</h2><p>在开发Android应用时,加新功能是必不可少的，我们加入了新的功能，有的一看界面就可以看出来，但是有的新功能就比较隐蔽，也就是用户很难知道你添加了这个新功能，这个时候就需要用户在打开我们的应用时给出一些提示，说明我们在哪里添加了新功能，点击哪里可以看到这个新功能。这时我们第一时间想到的可能是Toast，因为它用法简单，又不影响用户操作，但是它有个缺点，就是不能明确的指示是哪里添加了新功能，除非你用文字描述出来。为此，我基于Toast编写了一个小组件FloatTextToast（下面遇到的这个名字代替我写的这个组件），他和Toast的用法一样简单，并且弥补了Toast的缺点，也更显得更好看。</p>
<h2 id="效果图">效果图</h2><p><img src="http://hi.csdn.net/attachment/201112/10/0_13234942045Irb.gif" alt=""></p>
<h2 id="你可以学到">你可以学到</h2><ol>
<li>Toast的基本用法</li>
</ol>
<ol>
<li>Android的消息机制，如何创建自己的消息队列</li>
</ol>
<ol>
<li>怎样在Activity启动时获取一个View的width、height、top、left等属性</li>
</ol>
<h2 id="基本思路">基本思路</h2><ol>
<li>首先你要有一个处理好的9 PNG的图片，用于自适应文字显示，关于9 PNG处理可以参考Android Doc</li>
</ol>
<ol>
<li>要显示在哪个View的下面，就要知道这个目标View的位置</li>
</ol>
<ol>
<li>把要显示的文本放在一个TextView里，使用Toast的setView方法设置Toast要显示的View</li>
</ol>
<ol>
<li>根据得到的位置，最后就是使用Toast的setGravity方法把要显示的内容放到正确的位置显示出来即可。</li>
</ol>
<p>总的来说首先就是要知道目标View，根据targetView计算出要显示提示的位置，然后根据位置使用Toast把提示的文本显示出来。但是这里有几个难点，下面就一一解决</p>
<h2 id="Activity加载完成时获取targetVIew的宽高和位置属性">Activity加载完成时获取targetVIew的宽高和位置属性</h2><p>我们加入了新的功能提示，自然会在用户打开这个界面的时候就提示，但是在UI没有渲染完成绑定倒Window上的时候，是不能获取倒targetView的width、height和position的，那么我们怎么才能知道targetView的这些属性呢？Activity的onAttachedToWindow回调方法是不能用的，况且它是在API 5加上的，以前的API中并没有。不过我们还有一种方法，那就是在显示提示的时候获取targetView的属性，如果获取不到（为0）就一直获取，直到获取到为止，这其实是一个轮询。为了达到这一目的，我们在开发者调用FloatTextToast.show()的时候使用Android的Message机制轮询获取一个targetView的属性，如果获取到，就会显示提示文字了。在此之前先看下FloatTextToast构造函数，可以对它有个大概的了解，防止后面的代码中出现的成员变量不认识。</p>
<pre><code><span class="function"><span class="keyword">private</span> <span class="title">FloatTextToast</span><span class="params">(Context context,View targetView)</span> </span>{
        <span class="keyword">this</span>.mTargetView = targetView;
        <span class="keyword">this</span>.mContext= context;
        mToast=<span class="keyword">new</span> Toast(mContext);
        mContentView=<span class="keyword">new</span> TextView(mContext);
        mContentView.setBackgroundResource(R.drawable.float_text_toast_bg);
        mContentView.setTextColor(Color.BLACK);
        mContentView.setTextSize(TypedValue.COMPLEX_UNIT_DIP,<span class="number">16</span>);
        mToast.setView(mContentView);

        <span class="comment">//初始化一个Handler线程</span>
        mHandlerThread=<span class="keyword">new</span> HandlerThread(<span class="string">"FloatTextToast"</span>);
        mHandlerThread.start();
        mHandler=<span class="keyword">new</span> FloatTextToastHandler(mHandlerThread.getLooper());
    }
</code></pre><h2 id="自定义自己的消息循环机制">自定义自己的消息循环机制</h2><p>要想在一个自定义的组件中使用Message机制，一定要有自己的Looper机制，我们不能使用Activity的Looper，因为主Looper可能会有其他的Message需要处理，这就会导致我们的show方法会延迟调用，这样效果就不好了，所以要有一个专门的Looper来处理此Message。要声明自己的Looper，就需要HandlerThread这个类的配合了，这可是个好东西，使用它你会很容易的创建一个自己的线程用于处理你Message。使用方法很简单，如下代码：</p>
<pre><code><span class="comment">//初始化一个Handler线程</span>
        mHandlerThread=<span class="keyword">new</span> HandlerThread(<span class="string">"FloatTextToast"</span>);
        mHandlerThread.start();
        mHandler=<span class="keyword">new</span> FloatTextToastHandler(mHandlerThread.getLooper());
</code></pre><p>这样就声明了一个HandlerThread并且让它运行，运行之后我们就可以获取一个属于该Thread的Looper，然后把Message发送给这个Looper，那么这个线程就可以处理你发送的消息了。。看看我们的自定义Handler</p>
<pre><code><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FloatTextToastHandler</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Handler</span>{</span>

        public <span class="type">FloatTextToastHandler</span>(<span class="type">Looper</span> looper) {
            <span class="keyword">super</span>(looper);
        }

        <span class="annotation">@Override</span>
        public void handleMessage(<span class="type">Message</span> msg) {
            switch(msg.what){
            <span class="keyword">case</span> <span class="type">WHAT_SHOW</span>:
                showInHandler();
            }
        }

    }
</code></pre><p>它需要传递一个Looper作为构造参数声明，意思就是使用这个Looper处理我发send的Message的意思。上面的代码</p>
<pre><code>mHandler=<span class="keyword">new</span> <span class="type">FloatTextToastHandler</span>(mHandlerThread.getLooper<span class="literal">()</span>);
</code></pre><p>正是我们使用自己开启的线程处理我们的Message的意思。下面看下我们的showInHandler()方法是怎么处理的。</p>
<pre><code>/**在<span class="type">Handler</span>调用的show方法，主要为了等待{@link #mTargetView}的位置*/
    <span class="keyword">private</span> void showInHandler<span class="literal">()</span>{
        <span class="built_in">int</span><span class="literal">[]</span> targetPos=getTargetViewPos<span class="literal">()</span>;
        <span class="keyword">if</span>(targetPos[<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;targetPos[<span class="number">1</span>]==<span class="number">0</span>){
            mHandler.sendEmptyMessageDelayed(<span class="type">WHAT_SHOW</span>, <span class="number">100</span>);
        }<span class="keyword">else</span>{
            final <span class="type">Rect</span> contentPos=getContentViewPos(targetPos);
            mToast.setGravity(<span class="type">Gravity</span>.<span class="type">LEFT</span>|<span class="type">Gravity</span>.<span class="type">TOP</span>, contentPos.left, contentPos.top);
            mToast.show<span class="literal">()</span>;
        }
    }
</code></pre><p>该方法其实就是在获取targetVIew的位置，如果获取不到，则向自定义的Looper里发送一个Message重新调用该函数，如果得到了位置，那么就调用Toast的setGravity方法设置好要显示文本的位置，然后显示即可。</p>
<h2 id="获取要显示文本的位置">获取要显示文本的位置</h2><p>要获取显示的位置，就要知道targetVIew的位置以及它的宽、高，这样就能计算要显示文本的位置了。View组件都有一个函数，可以把自己在Window里的坐标转换为一个数组。</p>
<pre><code><span class="keyword">private</span> <span class="built_in">int</span><span class="literal">[]</span> getTargetViewPos<span class="literal">()</span>{
        final <span class="built_in">int</span><span class="literal">[]</span> targetPos=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>];
        mTargetView.getLocationInWindow(targetPos);
        return targetPos;
    }
</code></pre><p>这样，就返回了targetView的xy坐标了。光有targetView的坐标还不够，还要有contentView最终要显示的位置。</p>
<pre><code><span class="comment">/**
     * 计算获取浮动文本显示的位置，把浮动文本放在targetView的中心处
     * @return 一个包含top和left的Rect
     */</span>
    <span class="keyword">private</span>  Rect getContentViewPos(<span class="built_in">int</span>[] targetPos){
        <span class="keyword">final</span> Rect windowVisibleRect=<span class="keyword">new</span> Rect();
        <span class="keyword">final</span> View targetView=mTargetView;
        <span class="keyword">final</span> TextView contentView=mContentView;
        <span class="comment">//状态栏高度</span>
        targetView.getWindowVisibleDisplayFrame(windowVisibleRect);
        <span class="built_in">int</span> statusBarHeight=windowVisibleRect.top;

        <span class="comment">//背景图那个三角箭头的位置</span>
        <span class="keyword">final</span> TextPaint textPaint=contentView.getPaint();
        <span class="built_in">int</span> contentW=(<span class="built_in">int</span>)textPaint.measureText((<span class="keyword">String</span>)contentView.getText());
        <span class="built_in">int</span> arrowPos=(<span class="built_in">int</span>)(contentW*(<span class="number">30.0</span>/<span class="number">160</span>));

        <span class="keyword">final</span> Rect <span class="built_in">rect</span> = <span class="keyword">new</span> Rect();
        <span class="built_in">rect</span>.left = targetPos[<span class="number">0</span>]+targetView.getWidth()/<span class="number">2</span>-arrowPos;
        <span class="built_in">rect</span>.top = targetPos[<span class="number">1</span>]-statusBarHeight + targetView.getHeight();
        <span class="keyword">return</span> <span class="built_in">rect</span>;
    }
</code></pre><p>这个函数的功能就是让文本显示在targetView的下方的横向中间的位置，也就是文本的背景尖角三角要指向targetView横向中间的位置，这样才好看些。为了这个才需要使用Paint测量文本的宽度，所以这也是该组件的一个缺陷，不能显示String格式之外的字符，比如SpannableString。</p>
<h2 id="完整的组件代码">完整的组件代码</h2><p>上面是对组件代码的拆分讲解，是为了说明我们当时实现这个组件的想法以及步骤，下面就整体把代码列出来，明了的看一下。</p>
<pre><code><span class="javadoc">/**
 * 浮动的文本显示。根据一个提供的View，可以把文本显示到该View的下面.
 * 可以设置显示的时间，多了该时间后自动消失。目前只支持纯文本{@link String}类型的显示
 * 因为要计算显示文本的宽度。
 *<span class="javadoctag"> @author</span> michael_li(飞雪无情)
 *<span class="javadoctag"> @since</span> 2011-12-10 下午04:57:36
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FloatTextToast</span> </span>{
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LENGTH_LONG=Toast.LENGTH_LONG;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LENGTH_SHORT=Toast.LENGTH_SHORT;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WHAT_SHOW=<span class="number">1</span>;

    <span class="keyword">private</span> Context mContext;
    <span class="keyword">private</span> View mTargetView;
    <span class="keyword">private</span> Toast mToast;
    <span class="keyword">private</span>  TextView mContentView;

    <span class="keyword">private</span> HandlerThread mHandlerThread;
    <span class="keyword">private</span> FloatTextToastHandler mHandler;
    <span class="function"><span class="keyword">private</span> <span class="title">FloatTextToast</span><span class="params">(Context context,View targetView)</span> </span>{
        <span class="keyword">this</span>.mTargetView = targetView;
        <span class="keyword">this</span>.mContext= context;
        mToast=<span class="keyword">new</span> Toast(mContext);
        mContentView=<span class="keyword">new</span> TextView(mContext);
        mContentView.setBackgroundResource(R.drawable.float_text_toast_bg);
        mContentView.setTextColor(Color.BLACK);
        mContentView.setTextSize(TypedValue.COMPLEX_UNIT_DIP,<span class="number">16</span>);
        mToast.setView(mContentView);

        <span class="comment">//初始化一个Handler线程</span>
        mHandlerThread=<span class="keyword">new</span> HandlerThread(<span class="string">"FloatTextToast"</span>);
        mHandlerThread.start();
        mHandler=<span class="keyword">new</span> FloatTextToastHandler(mHandlerThread.getLooper());
    }
    <span class="javadoc">/**
     * 生成一个FloatTextToast
     *<span class="javadoctag"> @param</span> context Activity 上下文
     *<span class="javadoctag"> @param</span> targetView  目标View，浮动文本要显示在哪个View下面
     *<span class="javadoctag"> @param</span> text 要显示的文本
     *<span class="javadoctag"> @param</span> duration 浮动文本显示的时间 {@link #LENGTH_LONG} {@link #LENGTH_SHORT}
     *<span class="javadoctag"> @return</span> 一个FloatTextToast，可以调用{@link #show()}显示
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FloatTextToast <span class="title">makeText</span><span class="params">(Context context,View targetView, String text, <span class="keyword">int</span> duration)</span> </span>{
        <span class="keyword">final</span> FloatTextToast floatToast=<span class="keyword">new</span> FloatTextToast(context,targetView);
        <span class="keyword">final</span> TextView contentView=floatToast.mContentView;
        contentView.setText(text);
        floatToast.mToast.setDuration(duration);
        <span class="keyword">return</span> floatToast;
    }
    <span class="javadoc">/**
     * 显示浮动文本
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>{
        mHandler.sendEmptyMessage(WHAT_SHOW);
    }
    <span class="javadoc">/**在Handler调用的show方法，主要为了等待{@link #mTargetView}的位置*/</span>
    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showInHandler</span><span class="params">()</span></span>{
        <span class="keyword">int</span>[] targetPos=getTargetViewPos();
        <span class="keyword">if</span>(targetPos[<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;targetPos[<span class="number">1</span>]==<span class="number">0</span>){
            mHandler.sendEmptyMessageDelayed(WHAT_SHOW, <span class="number">100</span>);
        }<span class="keyword">else</span>{
            <span class="keyword">final</span> Rect contentPos=getContentViewPos(targetPos);
            mToast.setGravity(Gravity.LEFT|Gravity.TOP, contentPos.left, contentPos.top);
            mToast.show();
        }
    }
    <span class="keyword">private</span> <span class="keyword">int</span>[] getTargetViewPos(){
        <span class="keyword">final</span> <span class="keyword">int</span>[] targetPos=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];
        mTargetView.getLocationInWindow(targetPos);
        <span class="keyword">return</span> targetPos;
    }
    <span class="javadoc">/**
     * 计算获取浮动文本显示的位置，把浮动文本放在targetView的中心处
     *<span class="javadoctag"> @return</span> 一个包含top和left的Rect
     */</span>
    <span class="function"><span class="keyword">private</span>  Rect <span class="title">getContentViewPos</span><span class="params">(<span class="keyword">int</span>[] targetPos)</span></span>{
        <span class="keyword">final</span> Rect windowVisibleRect=<span class="keyword">new</span> Rect();
        <span class="keyword">final</span> View targetView=mTargetView;
        <span class="keyword">final</span> TextView contentView=mContentView;
        <span class="comment">//状态栏高度</span>
        targetView.getWindowVisibleDisplayFrame(windowVisibleRect);
        <span class="keyword">int</span> statusBarHeight=windowVisibleRect.top;

        <span class="comment">//背景图那个三角箭头的位置</span>
        <span class="keyword">final</span> TextPaint textPaint=contentView.getPaint();
        <span class="keyword">int</span> contentW=(<span class="keyword">int</span>)textPaint.measureText((String)contentView.getText());
        <span class="keyword">int</span> arrowPos=(<span class="keyword">int</span>)(contentW*(<span class="number">30.0</span>/<span class="number">160</span>));

        <span class="keyword">final</span> Rect rect = <span class="keyword">new</span> Rect();
        rect.left = targetPos[<span class="number">0</span>]+targetView.getWidth()/<span class="number">2</span>-arrowPos;
        rect.top = targetPos[<span class="number">1</span>]-statusBarHeight + targetView.getHeight();
        <span class="keyword">return</span> rect;
    }
    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FloatTextToastHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>{

        <span class="function"><span class="keyword">public</span> <span class="title">FloatTextToastHandler</span><span class="params">(Looper looper)</span> </span>{
            <span class="keyword">super</span>(looper);
        }

        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>{
            <span class="keyword">switch</span>(msg.what){
            <span class="keyword">case</span> WHAT_SHOW:
                showInHandler();
            }
        }

    }
}
</code></pre><p>此组件和Toast的实现方法一样，所以上手不难，只需使用makeText静态方法生成一个即可</p>
<pre><code>FloatTextToast.<span class="function"><span class="title">makeText</span><span class="params">(Context context, View targetView, String text, int duration)</span></span>.<span class="function"><span class="title">show</span><span class="params">()</span></span>
</code></pre><p>就这么简单，传进去几个参数，show出即可，和Toast一样好用。</p>
<h2 id="小结">小结</h2><p>这里主要是通过类之间的组合编写一个一个FloatTextToast组件，便于在应用中提示一些信息，不光局限于新功能的提示，还有其他的点击查看个人信息等等，就如上面的效果图一样。这里主要的难点就在于Activity启动获取targetView的状态，这里采用了不受影响的自定义的消息机制，能及时的获取targetView的状态。这里也采用的Toast的队列机制，这样就能够更好的一个个的提示，让用户看完一个再显示另外一个，不至于一下子全显示出来，而用户没有时间看。这里还采用了Paint用于测量文本的真实宽度，所以也有了一些缺陷，如果哪位有更好的方法，也可以留言告知我，不胜感激。</p>
<p><img src="http://hi.csdn.net/attachment/201112/10/0_1323508315BC94.gif" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.flysnow.org/2011/12/10/android-float-widget.html" data-id="ci7yv6947002zl0n10s4kstw2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>

  

  
    <article id="post-android-4-0-api-arrange" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2011/11/15/android-4-0-api-arrange.html" class="article-date">
  <time datetime="2011-11-14T22:06:48.000Z" itemprop="datePublished">2011-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/11/15/android-4-0-api-arrange.html">提取出的最新Android4.0 API 源代码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>提取出的Android4.0 API 的源代码，也就是android.jar源代码，这样在Eclipse关联到该源代码，就可以在项目中查看Android API 的实现了。</p>
<p>下载地址 <a href="http://download.csdn.net/detail/michael__li/3802305" target="_blank" rel="external">http://download.csdn.net/detail/michael__li/3802305</a></p>
<p>Android4.0 全部源代码下载方法 ：<a href="http://blog.csdn.net/michael__li/article/details/6971765" target="_blank" rel="external">http://blog.csdn.net/michael__li/article/details/6971765</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.flysnow.org/2011/11/15/android-4-0-api-arrange.html" data-id="ci7yv694a0036l0n19b1yzcva" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/API/">API</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>

  

  
    <article id="post-download-android-4-0-sources" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2011/11/15/download-android-4-0-sources.html" class="article-date">
  <time datetime="2011-11-14T17:41:00.000Z" itemprop="datePublished">2011-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/11/15/download-android-4-0-sources.html">最新最全的Android4.0 API源代码下载和完整Android4.0源代码下载教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这时刚刚整理好的最新的，包含所有的API的源代码，第一次上传的那个Android4.0 API 源代码有部分API没有包含，请点击下面的链接下载最新的。</p>
<p>附Android4.0 API 源代码下载<a href="http://download.csdn.net/detail/michael__li/3802305" target="_blank" rel="external">http://download.csdn.net/detail/michael__li/3802305</a></p>
<p>昨日凌晨Android放出4.0源代码，已经托管到GoogleSource上，大家可以下载了，这次放出的branch为Android-4.0.0_r1。</p>
<p>下载教程。操作系统环境为Linux,并且确保你已经安装了git jdk python等.</p>
<p>1.创建bin目录，并加入到PATH</p>
<pre><code>$ <span class="built_in">mkdir</span> ~/bin
$ <span class="built_in">PATH</span>=~/bin:$<span class="built_in">PATH</span>
</code></pre><p>2.下载repo到刚刚创建的bin目录，并设置权限为可执行。</p>
<pre><code><span class="variable">$ </span>curl <span class="symbol">https:</span>/<span class="regexp">/dl-ssl.google.com/dl</span><span class="regexp">/googlesource/git</span>-repo/repo &gt; ~<span class="regexp">/bin/repo</span>
<span class="variable">$ </span>chmod a+x ~<span class="regexp">/bin/repo</span>
</code></pre><p>3.创建Android源代码存放目录并进入到该目录</p>
<pre><code>$ mkdirAndroid-<span class="number">4.0</span><span class="number">.0</span>_<span class="built_in">r1</span>
$ cdAndroid-<span class="number">4.0</span><span class="number">.0</span>_<span class="built_in">r1</span>
</code></pre><p>4.初始化Android4.0.1的Git库</p>
<pre><code><span class="variable">$ </span>repo init -u <span class="symbol">https:</span>/<span class="regexp">/android.googlesource.com/platform</span><span class="regexp">/manifest -b android-4.0.1_r1</span>
</code></pre><p>5.最后执行开始同步下载</p>
<pre><code><span class="variable">$ </span>repo sync
</code></pre><p>然后就是漫长的等待了。。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.flysnow.org/2011/11/15/download-android-4-0-sources.html" data-id="ci7yv69490032l0n1jkybliss" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ubuntu/">Ubuntu</a></li></ul>

    </footer>
  </div>
  
</article>

  

  
    <article id="post-android-asset-studio-integration" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2011/11/11/android-asset-studio-integration.html" class="article-date">
  <time datetime="2011-11-11T08:18:00.000Z" itemprop="datePublished">2011-11-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/11/11/android-asset-studio-integration.html">Android设计应用图标不用愁---Asset Studio Integration来帮你</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://android-ui-utils.googlecode.com/hg/asset-studio/dist/index.html" target="_blank" rel="external">Android Asset Studio</a>Web版是一个非常好用的Andrid图标资源设计工具，它是由RomanNurik开发的。现在我们已经在ADT14里支持同样的功能。首先，你要打开新建向导（Ctrl-N）,选择Android分类，然后在其下找到名字为“Android Icon Set”的这一项：</p>
<p><img src="http://hi.csdn.net/attachment/201111/10/0_13209351362229.gif" alt=""></p>
<p>然后，将会弹出“资源选择器”（这些资源其实就是你在布局文件用到的那些图片，比如对于上下文菜单自定义的背景图片，就需要一个为“Background”属性设置一个@drawable的引用）对话框，该对话框里有个按钮(Create New Icon…)，点击它.</p>
<p><img src="http://hi.csdn.net/attachment/201111/10/0_1320936348j75Y.gif" alt=""></p>
<p>当你打开Android Icon Set向导的时候，首先看到的是一个资源类型选择界面，也就是你想创建哪一类图标：</p>
<p><img src="http://hi.csdn.net/attachment/201111/10/0_1320936495Wu61.gif" alt=""></p>
<p>在这里，你可以选择创建哪一类图标，并且为这个被创建的图标起一个名字。</p>
<p>如果你选择创建一个启动图标并且单击了下一步，这时你会看到如下界面：</p>
<p><img src="http://hi.csdn.net/attachment/201111/10/0_1320936654FoRB.gif" alt=""></p>
<p>这个界面包含很多功能。首先你会在右边看到我们正在创建和处理的图标的预览图。正如你所看到的，针对不同分辨率的屏幕它创建了多个图标，这就是刚刚为什么我们指的是一个“图标集合”，而不仅仅是一个“图标”。除了上面显示的，我们还创建了一个高分辨率的“web”版本的图标，你可能会在上传应用到Android Market的时候用到它（译者按：在上传App倒Android<br>Market的时候，可以上传一个大图标）。</p>
<p><img src="http://hi.csdn.net/attachment/201111/10/0_1320937517H8eb.gif" alt=""></p>
<p>仔细看下这个图标，你会发现它比我们在上面预览（Preview）那里看到的更有光泽。你可以选择界面上的“Glossy”选项来使得你的图标具有光泽的效果。</p>
<p><img src="http://hi.csdn.net/attachment/201111/10/0_1320937955mwIb.gif" alt=""></p>
<p>你还可以设置背景的形状。文本的字体、颜色等等。</p>
<p><img src="http://hi.csdn.net/attachment/201111/10/0_1320938081E0sR.gif" alt=""></p>
<p>然而，使用文本并不能做出非常好的图标，但是请注意，这仅仅是我们为了得到初步的效果而采取的一种很快捷的方式。请注意界面的最上面还有三个功能选项：</p>
<ul>
<li>图片</li>
</ul>
<ul>
<li>剪贴画</li>
</ul>
<ul>
<li>文本</li>
</ul>
<p>理想情况下你会用你自己的“基准”图像（或者如果需要的话会是一个剪贴画），然后使用Asset Studio 向导生成合适的图标。</p>
<p>你会问了：“我已经有了一个自己绘制好的图标了，那么我为什么还要再生成”？原因就是Anroid有不同的版本、不同的主题，这就意味着你会提供不同效果、不同颜色以及不同样式的图标。比如下面我为状态栏和通知栏生成的图标：</p>
<p><img src="http://hi.csdn.net/attachment/201111/10/0_1320939254gexG.gif" alt=""></p>
<p>你可以看到使用的基准图像只是一个简单的黑白相间的Bugdroid图像，但是我们为Gingerbread(v9)、Honeycomb(v11)以及老的版本都生成了不同样式的图标。对于ActionBar，Asset Studio向导会生成亮、暗两种不同Holo 主题的图标。对于选项卡则会生成“选中”和“未选中”两种不同样式的图标，并且对于v5（Andoid2.0）之前的版本则会新生成不同演示的“未选中”状态的图标（译者按：Asset<br>Studio对于v5版本前后生成的“为选中”图标是不一样的，从下图可以看出，v5之前的图标发白，v5之后的发灰）。</p>
<p><img src="http://hi.csdn.net/attachment/201111/10/0_1320940269VMv2.gif" alt=""></p>
<p>使用Asset Studio的一个优势就是在你点击完成按钮后，它可以直接在你当前的项目中生成你设计好的图标。这样你就不用像使用Web版本（译者按：前面提到过，这个工具一开始是Web App，ADT14才加入进来，成为ADT的一部分）一样，还要下载下来并且提取图标放在正确的位置。它还会在图标名字冲突的时候提示你是否覆盖原文件。如果你在上面的资源选择器界面里点击了“Create<br>Icon”按钮，那么新创建的图标将会在选择器里被选中。</p>
<p>当你点击完成退出向导的时候，包资源管理器会自动更新并且选中新创建的图标。</p>
<p><img src="http://hi.csdn.net/attachment/201111/11/0_1321025460X3wc.gif" alt=""></p>
<p>和ADT集成的第二个优势就是我们可以知道你的项目工程的minimum SDK target，我们就可以利用这些信息仅仅生成必要的图标。比如你正在基于Android2.0或者以上版本开发一个App，那么我们将不会生成不需要的老的样式的图标，也不需要名字为drawable-mdpi-v5的文件夹等等；生成的图标直接会被放进drawable-mdpi文件夹里。</p>
<p>我们希望这些内容能让你更容易的创建很好的应用。请不要经常使用那个文本功能:（译者按：最好使用Image和Clipart两个）-)我们还仍需要为AOSP贡献更多的剪贴画，这样大家就可以在向导里选择使用（译者按：目前向导的剪贴画只有一个，可以参见前面的图片），所以如果你是个艺术设计者，我们非常欢迎你贡献些剪贴画出来！（请参见<a href="http://tools.android.com/contributing" target="_blank" rel="external">贡献页面</a>）</p>
<p>非常感谢Roman Nurik写出了这么好的网页应用并且为移植到ADT提供了帮助。</p>
<p>译自：<a href="http://tools.android.com/recent/assetstudiointegration" target="_blank" rel="external">http://tools.android.com/recent/assetstudiointegration</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.flysnow.org/2011/11/11/android-asset-studio-integration.html" data-id="ci7yv694d003al0n1kmm7amvm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>

  

  
    <article id="post-adsl-and-vpn-config-for-ubuntu" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2011/10/22/adsl-and-vpn-config-for-ubuntu.html" class="article-date">
  <time datetime="2011-10-22T08:06:17.000Z" itemprop="datePublished">2011-10-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/10/22/adsl-and-vpn-config-for-ubuntu.html">Ubuntu下ADSL拨号和VPN 访问网站</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-更新NetworkManager">1.更新NetworkManager</h2><p>添加更新源：deb <a href="http://ppa.launchpad.net/network-manager/trunk/ubuntu" target="_blank" rel="external">http://ppa.launchpad.net/network-manager/trunk/ubuntu</a> maverick main</p>
<p>deb-src <a href="http://ppa.launchpad.net/network-manager/trunk/ubuntu" target="_blank" rel="external">http://ppa.launchpad.net/network-manager/trunk/ubuntu</a> maverick main</p>
<p>执行sudo apt-get update更新，然后打开更新管理器进行更新软件。</p>
<h2 id="2-启用NetworkManager。">2.启用NetworkManager。</h2><p>修改/etc/NetworkManager/NetworkManager.conf文件里的managed为true保存。修改/etc/network/interfaces文件，只保留最上面两行的auto lo iface lo inet loopback,然后删除/etc/resolv.conf，最后重启networkmanager sudo /etc/init.d/network-manager restart。</p>
<h2 id="3-添加DSL和VPN配置">3.添加DSL和VPN配置</h2><p>看到面板里的网络链接，编辑他，添加DSL链接，之用输入用户名和密码即可，VPN链接选用pptp协议，输入服务器地址和用户名密码即可</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.flysnow.org/2011/10/22/adsl-and-vpn-config-for-ubuntu.html" data-id="ci7yv694h003dl0n1wfgjsigx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ubuntu/">Ubuntu</a></li></ul>

    </footer>
  </div>
  
</article>

  

  
    <article id="post-android-send-email-intro" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2011/07/19/android-send-email-intro.html" class="article-date">
  <time datetime="2011-07-19T06:50:52.000Z" itemprop="datePublished">2011-07-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/07/19/android-send-email-intro.html">Android中我为什么发不了邮件--Android邮件发送详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Android中我为什么发不了邮件？？？我手机里明明有邮件客户端的，可我为什么不能调用它发送邮件？？？相信这是很多人会问的问题，手机里有Email客户端，可是偏偏在自己的应用里调用不了，抑或是不知道怎么调用，还有的是一直认为自己写对了，可是偏偏不能调用，无奈之下只能却网上找段代码粘贴上，ok，可以了。。可是你知道别人的代码为什么可以？你知道调用Email是怎么工作的吗？如果你又像给多人发邮件，还想发送附件，怎么做？又迷糊了吧？所以需要搞懂原理才能一通百通，举一反三，而这就是这篇博文要写的，也是你可以在这篇博文中学到的。</p>
<p>在这里你可以学到：</p>
<ol>
<li>什么是Intent和Intent Fileter</li>
</ol>
<ol>
<li>如何发送Email</li>
</ol>
<ol>
<li>如何发送特定的标题和内容的Emil</li>
</ol>
<ol>
<li>如何发送给多人</li>
</ol>
<ol>
<li>如何抄送和密送</li>
</ol>
<ol>
<li>如何发送附件</li>
</ol>
<h2 id="一：什么是Intent和Intent_Fileter">一：什么是Intent和Intent Fileter</h2><p>关于这个详细介绍请参考 :</p>
<p><a href="/2011/03/14/android-intents-and-intent-filters-one.html">Intents and Intent Filters(一)</a></p>
<p><a href="/2011/03/17/android-intents-and-intent-filters-two.html">Intents and Intent Filters(二)</a></p>
<p><a href="/2011/03/29/android-intents-and-intent-filters-three.html">Intents and Intent Filters(三)</a></p>
<h2 id="二：如何发送Email">二：如何发送Email</h2><p>通过上面就会知道Android应用之间的通信是通过Intent这个东西，如果手机中有实现了你想要功能的应用那么你就不用麻烦去实现一个拉。直接使用就可以，比如这里的发送邮件。</p>
<p>我们新建一个工程SendEmail，基于Android1.6实现。然后定义布局文件和代码如下：</p>
<pre><code>&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;
&lt;<span class="type">LinearLayout</span> xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>
    android:orientation=<span class="string">"vertical"</span>
    android:layout_width=<span class="string">"fill_parent"</span>
    android:layout_height=<span class="string">"fill_parent"</span>
    &gt;
&lt;<span class="type">Button</span>
    android:id=<span class="string">"@+id/send_btn"</span>  
    android:layout_width=<span class="string">"fill_parent"</span> 
    android:layout_height=<span class="string">"wrap_content"</span> 
    android:text=<span class="string">"Send Action"</span>
    /&gt;
&lt;/<span class="type">LinearLayout</span>&gt;





 <span class="comment">/** 发送邮件测试界面
 * @author 飞雪无情
 * ＠since 2011-7-19
 */</span>
public <span class="class"><span class="keyword">class</span> <span class="title">SendEmailActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Activity</span> <span class="title">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span>{</span>
    <span class="keyword">private</span> <span class="type">Button</span> mSendBtn;
    <span class="comment">/** Called when the activity is first created. */</span>
    <span class="annotation">@Override</span>
    public void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.main);
        mSendBtn=(<span class="type">Button</span>)findViewById(<span class="type">R</span>.id.send_btn);
        mSendBtn.setOnClickListener(<span class="keyword">this</span>);
    }
    <span class="annotation">@Override</span>
    public void onClick(<span class="type">View</span> v) {
        switch(v.getId()){
        <span class="keyword">case</span> <span class="type">R</span>.id.send_btn:
            startSendEmailIntent();
            <span class="keyword">break</span>;
        }
    }
    <span class="keyword">private</span> void startSendEmailIntent(){
        <span class="type">Intent</span> data=<span class="keyword">new</span> <span class="type">Intent</span>(<span class="type">Intent</span>.<span class="type">ACTION_SENDTO</span>);
        data.setData(<span class="type">Uri</span>.parse(<span class="string">"mailto:qq10000@qq.com"</span>));
        data.putExtra(<span class="type">Intent</span>.<span class="type">EXTRA_SUBJECT</span>, <span class="string">"这是标题"</span>);
        data.putExtra(<span class="type">Intent</span>.<span class="type">EXTRA_TEXT</span>, <span class="string">"这是内容"</span>);
        startActivity(data);
    }
}
</code></pre><p>这是我们运行应用，点击按钮就会看到如下效果:</p>
<p><img src="http://dl.iteye.com/upload/attachment/520422/f01623aa-77eb-3a1f-bf30-306092c83e0d.png" alt=""><br><img src="http://dl.iteye.com/upload/attachment/520425/ed85ef04-3760-33a4-a0e7-b4fc2701eaca.png" alt=""></p>
<h2 id="三：分析发送代码">三：分析发送代码</h2><p>主要的发送代码如下：</p>
<pre><code>Intent <span class="built_in">data</span><span class="subst">=</span><span class="literal">new</span> Intent(Intent<span class="built_in">.</span>ACTION_SENDTO);
<span class="built_in">data</span><span class="built_in">.</span>setData(Uri<span class="built_in">.</span>parse(<span class="string">"mailto:qq10000@qq.com"</span>));
<span class="built_in">data</span><span class="built_in">.</span>putExtra(Intent<span class="built_in">.</span>EXTRA_SUBJECT, <span class="string">"这是标题"</span>);
<span class="built_in">data</span><span class="built_in">.</span>putExtra(Intent<span class="built_in">.</span>EXTRA_TEXT, <span class="string">"这是内容"</span>);
startActivity(<span class="built_in">data</span>);
</code></pre><ol>
<li>首先构造一个Action为SENDTO的Action</li>
</ol>
<ol>
<li>其次创建一个Uri，他是一个mailto的邮件链接，也就是接收地址.</li>
</ol>
<ol>
<li>再通过Intent.EXTRA_SUBJECT和Intent.EXTRA_TEXT传递标题和文本的数据，记住，一定要使用这些常量，这是标准，否则Email客户端不认识，那样你传递的标题和文本就不起作用了。</li>
</ol>
<ol>
<li>然后就是startActivity进行打开，系统会根据Intent自动匹配找到能处理这个intent的应用，如图列表，有很多个，我们这里选择网易掌上邮，就打开了一个邮件发送界面，如我们所愿，邮件地址、标题和内容都在了，很成功.</li>
</ol>
<ol>
<li>intent中的数据传递是以Extra的方式进行put后传递的，然后在使用的时候getter取出使用。</li>
</ol>
<h2 id="四：发送给多人以及抄送和密送">四：发送给多人以及抄送和密送</h2><p>发送给多人以及抄送和密送都很简单，查找Intent类中的Extra常量，发送有这么三个常量:Intent.EXTRA_EMAIL,Intent.EXTRA_CC,Intent.EXTRA_BCC。这三个分别用于传递“接受人地址列表”、“抄送人地址列表”和“密送人地址列表”，传递的都是String[]类型的Email地址，如果数组中有多个地址，就可以发送给多人。发送的函数修改如下，我们看下效果:</p>
<pre><code>private <span class="keyword">void</span> startSendEmailIntent(){
        Intent data=<span class="keyword">new</span> Intent(Intent.ACTION_SENDTO);
        data.setData(<span class="built_in">Uri</span>.parse(<span class="string">"mailto:qq10000@qq.com"</span>));
        data.putExtra(Intent.EXTRA_EMAIL, <span class="keyword">new</span> <span class="built_in">String</span>[]{<span class="string">"ls8707@163.com"</span>,<span class="string">"ls8708@163.com"</span>});
        data.putExtra(Intent.EXTRA_CC, <span class="keyword">new</span> <span class="built_in">String</span>[]{<span class="string">"ls8709@163.com"</span>});
        data.putExtra(Intent.EXTRA_BCC, <span class="keyword">new</span> <span class="built_in">String</span>[]{<span class="string">"ls810@163.com"</span>});
        data.putExtra(Intent.EXTRA_SUBJECT, <span class="string">"这是标题"</span>);
        data.putExtra(Intent.EXTRA_TEXT, <span class="string">"这是内容"</span>);
        startActivity(data);
    }
</code></pre><p><img src="http://dl.iteye.com/upload/attachment/520438/c837b159-0616-3890-8344-2dd841b43585.png" alt=""></p>
<h2 id="五，发送附件">五，发送附件</h2><p>Email’客户端的发送Activity提供了两个Intent Filter，一个用于发送普通邮件，一个用户发送带有附件的邮件。区分很很容易的，发送普通邮件的那个Intent Filter配置的Action SENDTO，而带有附件的邮件则是SEND,所以是2个不一样，但是哪些比如附加“标题”，“内容”，“抄送”，“发送多人”等等还是通用的。布局文件新增一个按钮，用于发送带有附件的邮件，Activity代码也做修改。</p>
<pre><code>&lt;Button
    android:id=<span class="string">"@+id/send_to_btn"</span>  
    android:layout_width=<span class="string">"fill_parent"</span> 
    android:layout_height=<span class="string">"wrap_content"</span> 
    android:text=<span class="string">"SendTo Action"</span>/&gt;





 <span class="comment">/* * 发送邮件测试界面
 * @author 飞雪无情 
 * ＠since 2011-7-19
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendEmailActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>{
    <span class="keyword">private</span> Button mSendBtn;
    <span class="keyword">private</span> Button mSendToBtn;
    <span class="javadoc">/** Called when the activity is first created. */</span>
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        mSendBtn=(Button)findViewById(R.id.send_btn);
        mSendToBtn=(Button)findViewById(R.id.send_to_btn);
        mSendBtn.setOnClickListener(<span class="keyword">this</span>);
        mSendToBtn.setOnClickListener(<span class="keyword">this</span>);
    }
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{
        <span class="keyword">switch</span>(v.getId()){
        <span class="keyword">case</span> R.id.send_btn:
            startSendEmailIntent();
            <span class="keyword">break</span>;
        <span class="keyword">case</span> R.id.send_to_btn:
            startSendToEmailIntent();
            <span class="keyword">break</span>;
        }
    }
    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startSendEmailIntent</span><span class="params">()</span></span>{
        Intent data=<span class="keyword">new</span> Intent(Intent.ACTION_SENDTO);
        data.setData(Uri.parse(<span class="string">"mailto:qq10000@qq.com"</span>));
        data.putExtra(Intent.EXTRA_EMAIL, <span class="keyword">new</span> String[]{<span class="string">"ls8707@163.com"</span>,<span class="string">"ls8708@163.com"</span>});
        data.putExtra(Intent.EXTRA_CC, <span class="keyword">new</span> String[]{<span class="string">"ls8709@163.com"</span>});
        data.putExtra(Intent.EXTRA_BCC, <span class="keyword">new</span> String[]{<span class="string">"ls810@163.com"</span>});
        data.putExtra(Intent.EXTRA_SUBJECT, <span class="string">"这是标题"</span>);
        data.putExtra(Intent.EXTRA_TEXT, <span class="string">"这是内容"</span>);
        startActivity(data);
    }
    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startSendToEmailIntent</span><span class="params">()</span></span>{
        Intent data=<span class="keyword">new</span> Intent(Intent.ACTION_SEND);
        data.putExtra(Intent.EXTRA_EMAIL, <span class="keyword">new</span> String[]{<span class="string">"ls8707@163.com"</span>});
        data.putExtra(Intent.EXTRA_SUBJECT, <span class="string">"这是标题"</span>);
        data.putExtra(Intent.EXTRA_TEXT, <span class="string">"这是内容"</span>);
        data.putExtra(Intent.EXTRA_STREAM, Uri.parse(<span class="string">""</span>));
        data.setType(<span class="string">"text/plain"</span>);
        startActivity(data);
    }
}
</code></pre><p>运行应用，我们看到效果图里最小面的附件标识，说明已经可以发送附件了.</p>
<p><img src="http://dl.iteye.com/upload/attachment/520458/5ebe4f65-d647-3e0e-8a28-c351e8b5fccb.png" alt=""></p>
<p>发送附件最重要的就是Action必须为SEND，type一定要设置setType(“”),还要为Intent.EXTRA_STREAM赋值，类型为Uri，一个附件的Uri。这样才能发送附件。</p>
<h2 id="六，客户端Email应用的发送Activity配置">六，客户端Email应用的发送Activity配置</h2><p>这是Android1.6自带Email客户端的配置，如下：</p>
<pre><code><span class="tag">&lt;<span class="title">activity</span>
            <span class="attribute">android:name</span>=<span class="value">".activity.MessageCompose"</span>
            <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span>
            <span class="attribute">android:enabled</span>=<span class="value">"false"</span>
            &gt;</span>
            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.VIEW"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.SENDTO"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:scheme</span>=<span class="value">"mailto"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.BROWSABLE"</span> /&gt;</span>
            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>
            <span class="tag">&lt;<span class="title">intent-filter</span> <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span>&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.SEND"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:mimeType</span>=<span class="value">"text/plain"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:mimeType</span>=<span class="value">"image/*"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:mimeType</span>=<span class="value">"video/*"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span> /&gt;</span>
            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span>
</code></pre><p>从以上代码总结:</p>
<ol>
<li>一个Activity定义了2个Intent Filter用于发送不同类型邮件。</li>
</ol>
<ol>
<li>SENDTO发送普通邮件，SEND可以发送普通和带有附件的，不过最好主要用于发送附件。</li>
</ol>
<ol>
<li>使用SENDTO时，必须为Intent设置Data，也就是Uri，内容为”mailto:emailaddr”,否则不能匹配，因为有schema必须为mailto的限制</li>
</ol>
<ol>
<li>使用SEND时必须要设置type，也就是使用setType()方法，type只能为以前xml定义的4个。不过我测试了text/*也可以，其他的没测试.</li>
</ol>
<ol>
<li>发送附件只能使用SEND这个Action.</li>
</ol>
<p>附加Email客户端中提取Email地址，抄送，标题，附件等信息的源代码分析.</p>
<pre><code><span class="keyword">void</span> initFromIntent(Intent intent) {

        <span class="comment">//提取接受人地址列表</span>
        <span class="keyword">String</span>[] extraStrings = intent.getStringArrayExtra(Intent.EXTRA_EMAIL);
        <span class="keyword">if</span> (extraStrings != <span class="keyword">null</span>) {
            addAddresses(mToView, extraStrings);
        }
<span class="comment">//提取抄送人地址列表</span>
        extraStrings = intent.getStringArrayExtra(Intent.EXTRA_CC);
        <span class="keyword">if</span> (extraStrings != <span class="keyword">null</span>) {
            addAddresses(mCcView, extraStrings);
        }
<span class="comment">//提取密送人地址列表</span>
        extraStrings = intent.getStringArrayExtra(Intent.EXTRA_BCC);
        <span class="keyword">if</span> (extraStrings != <span class="keyword">null</span>) {
            addAddresses(mBccView, extraStrings);
        }
<span class="comment">//提取标题</span>
        <span class="keyword">String</span> extraString = intent.getStringExtra(Intent.EXTRA_SUBJECT);
        <span class="keyword">if</span> (extraString != <span class="keyword">null</span>) {
            mSubjectView.setText(extraString);
        }

        <span class="comment">//提取Uri中的接受人地址</span>
        <span class="keyword">final</span> Uri dataUri = intent.getData();
        <span class="keyword">if</span> (dataUri != <span class="keyword">null</span>) {
            <span class="keyword">if</span> (<span class="string">"mailto"</span>.equals(dataUri.getScheme())) {
                initializeFromMailTo(dataUri.toString());
            } <span class="keyword">else</span> {
                <span class="keyword">String</span> toText = dataUri.getSchemeSpecificPart();
                <span class="keyword">if</span> (toText != <span class="keyword">null</span>) {
                    addAddresses(mToView, toText.<span class="built_in">split</span>(<span class="string">","</span>));
                }
            }
        }

       <span class="comment">//提取邮件内容</span>

        CharSequence <span class="built_in">text</span> = intent.getCharSequenceExtra(Intent.EXTRA_TEXT);
        <span class="keyword">if</span> (<span class="built_in">text</span> != <span class="keyword">null</span>) {
            mMessageContentView.setText(<span class="built_in">text</span>);
        }

      <span class="comment">//提取附件，可以看出Action必须是SEND.EXTRA_STREAM中有数据</span>
     <span class="comment">//type不能为null,这样才能提取倒附件.</span>

        <span class="keyword">if</span> (Intent.ACTION_SEND.equals(intent.getAction()) &amp;&amp; intent.hasExtra(Intent.EXTRA_STREAM)) {
            <span class="keyword">String</span> type = intent.getType();
            Uri stream = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);
            <span class="keyword">if</span> (stream != <span class="keyword">null</span> &amp;&amp; type != <span class="keyword">null</span>) {
                <span class="keyword">if</span> (MimeUtility.mimeTypeMatches(type, Email.ACCEPTABLE_ATTACHMENT_SEND_TYPES)) {
                    addAttachment(stream);
                }
            }
        }

        <span class="comment">// Finally - expose fields that were filled in but are normally hidden, and set focus</span>

        <span class="keyword">if</span> (mCcView.length() &gt; <span class="number">0</span>) {
            mCcView.setVisibility(View.VISIBLE);
        }
        <span class="keyword">if</span> (mBccView.length() &gt; <span class="number">0</span>) {
            mBccView.setVisibility(View.VISIBLE);
        }
        setNewMessageFocus();
        mDraftNeedsSaving = <span class="keyword">false</span>;
    }
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.flysnow.org/2011/07/19/android-send-email-intro.html" data-id="ci7yv694j003gl0n19xa0lko0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Email/">Email</a></li></ul>

    </footer>
  </div>
  
</article>

  

  
    <article id="post-practices-of-an-agile-developer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2011/07/17/practices-of-an-agile-developer.html" class="article-date">
  <time datetime="2011-07-17T02:09:52.000Z" itemprop="datePublished">2011-07-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/软件开发/">软件开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/07/17/practices-of-an-agile-developer.html">高效程序员的45个习惯--敏捷开发修炼之道</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>笔者 写道<br>在去年就在豆瓣上看到这本不错的书，近来才拿到这本书好好的研读一下。读了之后又对本书有了更深的认识。我如此推崇她，因为我觉得她不像有些书那样的长篇大论，讲的都是大道理，看了云里雾里的。而这本书呢，讲的都是我们项目开发中实实在在遇到的，只是平时不太注意，作者只是用更朴素易懂的语言组织总结出来的一个个好习惯。</p>
<p>本书的文字言简意赅，写作方式采用坏习惯和好习惯的对比方式，当时也许你觉得这些习惯有点偏激，不过不要烦恼，因为每个习惯的最后作者都给出了中庸平衡之道。</p>
<p>相信很多人都有这本书，但是也有没有的，或者还不知道这本书，为了加深我自己对这45个习惯的理解和为了让更多的人知道、了解这45个习惯，所以我在这篇博客中记录下这45个习惯。前面我也提了，这本书言简意赅，所以对于习惯的总结更是如此，让我们可以一看到习惯的标题，就知道这个习惯的精髓所在。</p>
<h3 id="态度决定一切">态度决定一切</h3><ol>
<li>做事</li>
</ol>
<ol>
<li>欲速则不达</li>
</ol>
<ol>
<li>对事不对人</li>
</ol>
<ol>
<li>排除万难，奋勇前进</li>
</ol>
<h3 id="学无止境">学无止境</h3><ol>
<li>跟踪变化</li>
</ol>
<ol>
<li>对团队投资</li>
</ol>
<ol>
<li>懂得丢弃</li>
</ol>
<ol>
<li>打破沙锅问到底</li>
</ol>
<ol>
<li>把握开发节奏</li>
</ol>
<h3 id="交付用户想要的软件">交付用户想要的软件</h3><ol>
<li>让客户做决定</li>
</ol>
<ol>
<li>让设计指导而不是操纵开发</li>
</ol>
<ol>
<li>合理地使用技术</li>
</ol>
<ol>
<li>保持可以发布</li>
</ol>
<ol>
<li>提早集成，频繁集成</li>
</ol>
<ol>
<li>提早实现自动化部署</li>
</ol>
<ol>
<li>使用演示获得频繁反馈</li>
</ol>
<ol>
<li>使用短迭代，增量发布</li>
</ol>
<ol>
<li>固定的价格就意味着背叛承诺</li>
</ol>
<h3 id="敏捷反馈">敏捷反馈</h3><ol>
<li>守护天使（单元测试）</li>
</ol>
<ol>
<li>先用它再实现它</li>
</ol>
<ol>
<li>不同环境，就有不用问题</li>
</ol>
<ol>
<li>自动验收测试</li>
</ol>
<ol>
<li>度量真实的进度</li>
</ol>
<ol>
<li>倾听用户的声音</li>
</ol>
<h3 id="敏捷编码">敏捷编码</h3><ol>
<li>代码要清晰地表达意图</li>
</ol>
<ol>
<li>用代码沟通</li>
</ol>
<ol>
<li>动态评估取舍</li>
</ol>
<ol>
<li>增量式编程</li>
</ol>
<ol>
<li>保持简单</li>
</ol>
<ol>
<li>编写内聚的代码</li>
</ol>
<ol>
<li>告知，不要询问</li>
</ol>
<ol>
<li>根据契约进行替换</li>
</ol>
<h3 id="敏捷调试">敏捷调试</h3><ol>
<li>记录问题解决日志</li>
</ol>
<ol>
<li>警告就是错误</li>
</ol>
<ol>
<li>对问题各个击破</li>
</ol>
<ol>
<li>报告所有的异常</li>
</ol>
<ol>
<li>提供有用的错误信息</li>
</ol>
<h3 id="敏捷协作">敏捷协作</h3><ol>
<li>定期安排会面时间</li>
</ol>
<ol>
<li>架构师必须写代码</li>
</ol>
<ol>
<li>实行代码集体所有制</li>
</ol>
<ol>
<li>成为指导者</li>
</ol>
<ol>
<li>允许大家自己想办法</li>
</ol>
<ol>
<li>准备好后再共享代码</li>
</ol>
<ol>
<li>进行代码复查</li>
</ol>
<ol>
<li>及时通报进展与问题</li>
</ol>
<p>笔者 写道</p>
<p>这些都是些很不错的习惯，如果有你没有用到的，可以试着使用一下，有条件的也可以在团队推广使用，看看是否能带来惊喜。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.flysnow.org/2011/07/17/practices-of-an-agile-developer.html" data-id="ci7yv694m003ll0n17qsq8uem" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/敏捷/">敏捷</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/软件工程/">软件工程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/软件开发/">软件开发</a></li></ul>

    </footer>
  </div>
  
</article>

  

  
    <article id="post-android-thread-notice-item" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2011/05/21/android-thread-notice-item.html" class="article-date">
  <time datetime="2011-05-21T06:43:55.000Z" itemprop="datePublished">2011-05-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/05/21/android-thread-notice-item.html">Android中关于线程使用的几点注意事项</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们都知道Android是单线程模型，这意味着Android UI操作并不是线程安全的并且这些操作必须在UI线程中执行，所以你单纯的new一个Thrad并且start()不行的，因为这违背了Android的单线程模型。</p>
<p>很幸运的是Android为我们提供了在其他线程中访问UI线程的方法，相信大家都见过，这几个就是Activity的runOnUiThread方法，View的post和postDelayed方法，以及最常用的Hanlder和AsyncTask，这里我推荐使用Hanlder和AsyncTask，尤其是AsyncTask，因为使用他们你会发现你的代码很容易被理解，因为他们都有一些具有特定职责的方法，尤其是AsyncTask，有预处理的方法onPreExecute，有后台执行任务的方法doInBackground，有更新进度的方法publishProgress，有返回结果的方法onPostExecute等等，这就不像post这些方法，把所有的操作都一大坨的写在一个Runnable里。</p>
<p>有了Android为我们提供了这些方法我们就可以很好的解决一些长时间处理的任务了，但是在使用的时候我们还必须注意以下几点：</p>
<ol>
<li>这些方法或者类必须在在UI线程中创建和调用</li>
</ol>
<ol>
<li>其实这些方法和类最终的实现都是Android的Message、MessageQueue和Looper的机制，所以不要期待你会马上看到结果（效果），因为这是一个Loop一直循环出MessageQueue中的Message执行的过程，如果你没有看到效果，那么等等吧，因为还没有轮到你。</li>
</ol>
<ol>
<li>有线程（多个）的地方就会有并发，会有资源共享冲突，所以在使用的时候谨慎点吧，说不准你的一个线程中使用的变量已经被另一个线程改的面目全非了。。</li>
</ol>
<p>后语：忙的很久没有写博客了，搭黑写了平时总结的线程的注意事项，demo就不写了，相信大家都会，此外多了解点Android的消息机制对于这个理解比较好的多。。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.flysnow.org/2011/05/21/android-thread-notice-item.html" data-id="ci7yv694r003sl0n1fte3kosz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>

  

  
    <article id="post-android-intents-and-intent-filters-three" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2011/03/29/android-intents-and-intent-filters-three.html" class="article-date">
  <time datetime="2011-03-28T18:02:48.000Z" itemprop="datePublished">2011-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/03/29/android-intents-and-intent-filters-three.html">Android Intents and Intent Filters(三)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="数据(data)检测">数据(data)检测</h2><p>data标记也是在intent-filter中定义的，大致格式如下:</p>
<pre><code><span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.VIEW"</span>&gt;</span><span class="tag">&lt;/<span class="title">action</span>&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span>&gt;</span><span class="tag">&lt;/<span class="title">category</span>&gt;</span>
                <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:mimeType</span>=<span class="value">"text/plain"</span>&gt;</span><span class="tag">&lt;/<span class="title">data</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>
</code></pre><p>每个data定义一个URI和数据类型(MIME)，URI由4个属性来定义，分别是android:scheme,android:host,android:port,android:path..这个四个属性构成如下格式的URI:<br>scheme://host:port/path</p>
<p>如：content://com.flysnow.intent:8080/show/view。其中content就是scheme，com.flysnow.intent就是host，8080就是port,show/view就是path…如果有经常使用ContentProvider的应该熟悉。。我们经常定义的authority不就是host+port吗？还有这几个元素都是可选的，但是不是随便用就可以的，port要依赖于host，没有host，port就会被忽略，不起作用，同样，如果要使用host+port(authority)就必须指定scheme。而path则依赖于scheme和authority。。</p>
<p>还有一个很重要的类型就是mimeType,这个属性用于指定内容的类型，也就是这个组件可以处理哪些类型的内容。。如text/plain表示无格式文本类型，mimeType也支持通配符，使用text/*则表示所有文本类型。通过使用它，你可以很方便的开发出关联打开诸如txt文件，pdf文件的应用。后面的两个自理将会演示txt文件查看器，图片查看器的例子。。MIME可以参考<a href="http://www.w3school.com.cn/media/media_mimeref.asp。这里有所有的内容类型的定义。。" target="_blank" rel="external">http://www.w3school.com.cn/media/media_mimeref.asp。这里有所有的内容类型的定义。。</a></p>
<h3 id="开发实例-拨打电话，text阅读器和图片查看器">开发实例-拨打电话，text阅读器和图片查看器</h3><h3 id=""> </h3><p>下面通过一个例子来演示data的检测,项目名为Intents,应用名为Intents and Filters，运行在Android2.2版本上.主启动Activity为IntentsTestList。例子包括以下演示：</p>
<ol>
<li>通过发送intent的方式“打开拨号界面并输入电话123456”。</li>
</ol>
<ol>
<li>创建一个Text文件阅读器</li>
</ol>
<ol>
<li>创建一个图片查看器</li>
</ol>
<p>首先我们实现第一项，修改IntentsTestList类如下：</p>
<pre><code><span class="comment">/**
 * Intents测试列表类
 * @author 飞雪无情
 * @since 2011-3-14
 */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IntentsTestList</span> <span class="title">extends</span> <span class="title">ListActivity</span> {
    <span class="comment">/** Called when the activity is first created. */</span>
    @<span class="function">Override
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        super.onCreate(savedInstanceState);
      <span class="comment">//定义ListAdapter</span>
        setListAdapter(<span class="keyword">new</span> SimpleAdapter(<span class="keyword">this</span>, getData(),
                android.R.layout.simple_list_item_1, <span class="keyword">new</span> String[] { <span class="string">"title"</span> },<span class="keyword">new</span> <span class="keyword">int</span>[] {android.R.id.text1}));
        getListView().setTextFilterEnabled(<span class="keyword">true</span>);
    }
    @<span class="function">Override
    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onListItemClick</span><span class="params">(ListView l, View v, <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>{
        Intent intent=(Intent)getData().<span class="keyword">get</span>(position).<span class="keyword">get</span>(<span class="string">"intent"</span>);
        Boolean isActivity=(Boolean)getData().<span class="keyword">get</span>(position).<span class="keyword">get</span>(<span class="string">"isActivity"</span>);
        <span class="keyword">if</span>(isActivity){
            startActivity(intent);
        }<span class="keyword">else</span>{
            sendBroadcast(intent);
        }
    }

    <span class="comment">/**
     * 返回ListView需要的数据
     * @return ListView需要的数据
     */</span>
    <span class="keyword">private</span> List&lt;map&lt;<span class="keyword">string</span>,<span class="keyword">object</span>&gt;&gt; getData() {
        List&lt;map&lt;<span class="keyword">string</span>,<span class="keyword">object</span>&gt;&gt; data=<span class="keyword">new</span> ArrayList&lt;map&lt;<span class="keyword">string</span>,<span class="keyword">object</span>&gt;&gt;();
        addItem(data, <span class="string">"打开拨号界面并输入电话123456"</span>, <span class="keyword">new</span> Intent(Intent.ACTION_DIAL, Uri.parse(<span class="string">"tel://123456"</span>)), <span class="keyword">true</span>);
        <span class="keyword">return</span> data;
    }
    <span class="comment">/**
     * 给ListView添加数据
     * @param data 存储数据的List
     * @param name 要显示的Title
     * @param intent 单击某一项时要启动的Activity
     * @param isActivity 启动的是否是Activity，true是，false为广播
     */</span>
    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addItem</span><span class="params">(List&lt;map&lt;<span class="keyword">string</span>,<span class="keyword">object</span>&gt;&gt; data, String name, Intent intent,boolean isActivity)</span> </span>{
        Map&lt;<span class="keyword">string</span>, <span class="keyword">object</span>=<span class="string">""</span>&gt; temp = <span class="keyword">new</span> HashMap&lt;<span class="keyword">string</span>, <span class="keyword">object</span>=<span class="string">""</span>&gt;();
        temp.put(<span class="string">"title"</span>, name);
        temp.put(<span class="string">"intent"</span>, intent);
        temp.put(<span class="string">"isActivity"</span>, isActivity);
        data.add(temp);
    }

}
</code></pre><p>这时我们运行程序，单击“打开拨号界面并输入电话123456”就会打开系统的自带的拨号界面，并且默认已经录入了要拨打的号码“123456”。效果图如下：<br><img src="http://dl.iteye.com/upload/attachment/449159/2d492720-aea1-316f-a85f-52e465d8b106.png" alt=""></p>
<p><img src="http://dl.iteye.com/upload/attachment/449161/b0112c45-6c10-351d-a538-80b8b0a34b6c.png" alt=""></p>
<h3 id="然后我们实现第二功能-txt文件阅读器">然后我们实现第二功能-txt文件阅读器</h3><p>新建TextWatcherActivity代码如下：</p>
<pre><code><span class="javadoc">/**
 * 显示文本的Activity
 *<span class="javadoctag"> @author</span> 飞雪无情
 *<span class="javadoctag"> @since</span> 2011-3-24
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextWatcherActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>{
    <span class="keyword">private</span> TextView mTextView;

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        mTextView=<span class="keyword">new</span> TextView(<span class="keyword">this</span>);
        setContentView(mTextView);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onStart();
        Intent txtIntent=getIntent();
        Uri data=txtIntent.getData();
        String txt;
        <span class="keyword">try</span> {
            txt = readTxt(data);
        } <span class="keyword">catch</span> (IOException e) {
            txt=<span class="string">"打开txt文件异常"</span>;
        }
        mTextView.setText(txt);
    }
    <span class="javadoc">/**
     * 读取txt文本
     *<span class="javadoctag"> @param</span> txtUri
     *<span class="javadoctag"> @return</span>
     *<span class="javadoctag"> @throws</span> IOException
     */</span>
    <span class="keyword">private</span> <span class="function">String <span class="title">readTxt</span><span class="params">(Uri txtUri)</span> <span class="keyword">throws</span> IOException</span>{
        BufferedReader bufferedReader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(getContentResolver().openInputStream(txtUri),Charset.forName(<span class="string">"GBK"</span>)));
        StringBuilder txt=<span class="keyword">new</span> StringBuilder();
        String buf=<span class="string">""</span>;
        <span class="keyword">while</span>((buf=bufferedReader.readLine())!=<span class="keyword">null</span>){
            txt.append(buf).append(<span class="string">"\n"</span>);
        }
        <span class="function"><span class="keyword">return</span> txt.<span class="title">toString</span><span class="params">()</span></span>;
    }

}
</code></pre><p>然后在AndroidManifest.xml中加入如下定义:</p>
<pre><code><span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".TextWatcherActivity"</span>
            <span class="attribute">android:label</span>=<span class="value">"查看TXT文件"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.VIEW"</span>&gt;</span><span class="tag">&lt;/<span class="title">action</span>&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span>&gt;</span><span class="tag">&lt;/<span class="title">category</span>&gt;</span>
                <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:mimeType</span>=<span class="value">"text/plain"</span>&gt;</span><span class="tag">&lt;/<span class="title">data</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span>
</code></pre><p>这样在单击txt文件的时候就可以选择我们的这个Activity对txt文件处理，显示其内容.我们新建一个1.txt文件，写上一些内容，放在我们的sd卡中，使用文件管理工具查看这个txt文件，会弹出如下图的提示，看到我们刚刚做的《TXT阅读器》了吧。</p>
<p><img src="http://dl.iteye.com/upload/attachment/449475/079e5ed7-7342-39bf-95af-c95ec024681c.png" alt=""></p>
<p>选择“查看TXT文件”，就可以看到我们的txt内容：</p>
<p><img src="http://dl.iteye.com/upload/attachment/449477/e1fb042a-0555-3e43-b225-7fe7fce94dad.png" alt=""></p>
<h3 id="最后实现第三个功能—图片查看器">最后实现第三个功能—图片查看器</h3><p>新建ImageWatcherActivity，代码如下：</p>
<pre><code><span class="javadoc">/**
 * 显示文本的Activity
 *<span class="javadoctag"> @author</span> 飞雪无情
 *<span class="javadoctag"> @since</span> 2011-3-24
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageWatcherActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>{
    <span class="keyword">private</span> <span class="keyword">final</span> String IMAGE_URI_KEY=<span class="string">"imageUriKey"</span>;
    <span class="keyword">private</span> Uri image;
    <span class="keyword">private</span> ImageView mImageView;

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        mImageView=<span class="keyword">new</span> ImageView(<span class="keyword">this</span>);
        setContentView(mImageView);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onStart();
        Intent txtIntent=getIntent();
        image=txtIntent.getData();
        <span class="comment">//对于大图片未做优化处理</span>
        mImageView.setImageURI(image);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);
        image=savedInstanceState.getParcelable(IMAGE_URI_KEY);
        mImageView.setImageURI(image);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>{
        <span class="keyword">super</span>.onSaveInstanceState(outState);
        outState.putParcelable(IMAGE_URI_KEY,image);
    }

}
</code></pre><p>然后在AndroidManifest.xml中加入如下定义:</p>
<pre><code><span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".ImageWatcherActivity"</span>
            <span class="attribute">android:label</span>=<span class="value">"查看图片文件"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.VIEW"</span>&gt;</span><span class="tag">&lt;/<span class="title">action</span>&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span>&gt;</span><span class="tag">&lt;/<span class="title">category</span>&gt;</span>
                <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:mimeType</span>=<span class="value">"image/*"</span>&gt;</span><span class="tag">&lt;/<span class="title">data</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span>
</code></pre><p>这样在单击图片文件的时候就可以选择我们的这个Activity对txt文件处理并且显示。</p>
<p><img src="http://dl.iteye.com/upload/attachment/449481/9b6c7d30-4ed9-3fb4-8615-42dea2f0e02c.png" alt=""></p>
<p><img src="http://dl.iteye.com/upload/attachment/449483/dba27c5a-45df-3339-9fa6-e2135cff7fb6.png" alt=""></p>
<h3 id="数据(data)检测小结">数据(data)检测小结</h3><p>对于data的匹配，如果说怎么怎么匹配，在什么情况下通过可能会比较难以理解，这里以一种简单的方式来解说。</p>
<p>假定我们定义的Intent Filter 的data标签为集合A，传递的Intent中包含的data为集合B，当B是A的子集时就通过了（Action和Category也得检测通过）。如果B为空（不配置data），那么A也得为空（不配置data）才能通过<br>。更详细（繁琐）的介绍请参考doc</p>
<h3 id="Intents_and_Intent_Filters总结">Intents and Intent Filters总结</h3><p>Android提供了以Intent的方式调用Android设备的内置Google应用，比如打电话，调用Google浏览器打开网页，搜索等。关于这方便的介绍可以参考Android开发文档《Intents List: Invoking Google Applications on Android Devices》这一节的介绍，很详细。docs/guide/appendix/g-app-intents.html。</p>
<p>Intent是一个很好的设计，它提供了一种在各个组建之间通信的方式，也为我们使用其他的应用的功能提供了可能，这样如果我们想在自己的应用打开一个网页，我们就不用特意迁入一个webview，我们直接调用Android内的浏览器打开即可。。</p>
<p>最后值得一提的是PackageManager这个类中为我们提供了一系列的query…()方法，可以让我们根据我们定义的Intent查询特定的匹配Intent Filter标记的所有组件。。有兴趣的可以研究一下。。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.flysnow.org/2011/03/29/android-intents-and-intent-filters-three.html" data-id="ci7yv694t003vl0n1gudz8oos" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Intent/">Intent</a></li></ul>

    </footer>
  </div>
  
</article>

  

  
    <article id="post-do-you-know-android-resource" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2011/03/28/do-you-know-android-resource.html" class="article-date">
  <time datetime="2011-03-27T19:22:31.000Z" itemprop="datePublished">2011-03-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/03/28/do-you-know-android-resource.html">android.resource://这个Uri你知道吗</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如何访问平时APK文件Res目录下的内容呢? 如果直接访问Apk下的assets目录可以使用AssetManager类处理，而需要访问<br>res/raw这样的文件夹怎么办呢? 这里Android123可以告诉大家APK在安装时已经解压缩，部分资源存放在/data/data<br>/package_name/这里， 比如我们想访问res/raw/android123.cwj文件，可以使用android.resource:<br>//package_name/“ + R.raw.android123 这个Uri，其中package_name是你工程的包名。<br>完整的处理代码为 Uri uri = Uri.parse(“android.resource://com.android123.Sample/raw/android123.cwj”); 即可使用工程res/raw目录下的文件了。</p>
<p>转自：<a href="http://www.android123.com.cn/androidkaifa/827.html" target="_blank" rel="external">http://www.android123.com.cn/androidkaifa/827.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.flysnow.org/2011/03/28/do-you-know-android-resource.html" data-id="ci7yv694x0040l0n1ww8iglir" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>

  

  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">38</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件开发/">软件开发</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/API/">API</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a><span class="tag-list-count">38</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Apache/">Apache</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Email/">Email</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Github/">Github</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gradle/">Gradle</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Http/">Http</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HttpClitent/">HttpClitent</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Intent/">Intent</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/">Nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/">PHP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/">Ubuntu</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Widget/">Widget</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/goagent/">goagent</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代理/">代理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开源/">开源</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/敏捷/">敏捷</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/翻墙/">翻墙</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/翻译/">翻译</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件工程/">软件工程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件开发/">软件开发</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/API/" style="font-size: 13.33px;">API</a><a href="/tags/Android/" style="font-size: 20px;">Android</a><a href="/tags/Apache/" style="font-size: 10px;">Apache</a><a href="/tags/Email/" style="font-size: 10px;">Email</a><a href="/tags/Github/" style="font-size: 10px;">Github</a><a href="/tags/Gradle/" style="font-size: 11.67px;">Gradle</a><a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a><a href="/tags/Http/" style="font-size: 10px;">Http</a><a href="/tags/HttpClitent/" style="font-size: 10px;">HttpClitent</a><a href="/tags/Intent/" style="font-size: 13.33px;">Intent</a><a href="/tags/Linux/" style="font-size: 15px;">Linux</a><a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a><a href="/tags/PHP/" style="font-size: 10px;">PHP</a><a href="/tags/Ubuntu/" style="font-size: 18.33px;">Ubuntu</a><a href="/tags/Widget/" style="font-size: 16.67px;">Widget</a><a href="/tags/goagent/" style="font-size: 10px;">goagent</a><a href="/tags/代理/" style="font-size: 10px;">代理</a><a href="/tags/开源/" style="font-size: 10px;">开源</a><a href="/tags/敏捷/" style="font-size: 10px;">敏捷</a><a href="/tags/数据库/" style="font-size: 10px;">数据库</a><a href="/tags/翻墙/" style="font-size: 10px;">翻墙</a><a href="/tags/翻译/" style="font-size: 10px;">翻译</a><a href="/tags/软件工程/" style="font-size: 10px;">软件工程</a><a href="/tags/软件开发/" style="font-size: 11.67px;">软件开发</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">三月 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">一月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">七月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">三月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">二月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">十二月 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">十一月 2013</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">十月 2013</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">三月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/02/">二月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">一月 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">十二月 2011</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/11/">十一月 2011</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/10/">十月 2011</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/07/">七月 2011</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/05/">五月 2011</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/03/">三月 2011</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/02/">二月 2011</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/01/">一月 2011</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/11/">十一月 2010</a><span class="archive-list-count">7</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/03/30/manage-your-android-project-with-gradle.html">使用Gradle管理你的Android Studio工程</a>
          </li>
        
          <li>
            <a href="/2015/03/19/android-process-application-init-databases-problem.html">Android多进程的数据库访问问题</a>
          </li>
        
          <li>
            <a href="/2015/03/10/github-page-with-hexo.html">使用Hexo在Github上搭建自己的博客</a>
          </li>
        
          <li>
            <a href="/2015/01/12/android-gradle-plugin-translate-done.html">Android Gradle插件中文指南</a>
          </li>
        
          <li>
            <a href="/2014/07/13/effective-programming-more-than-writing-code.html">高效能程序员的修炼</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 飞雪无情<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>